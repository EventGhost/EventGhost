# This is a wrapper class around a raw ir code.
# It is simply designed to provide some additional methods
# to parse the code easier.


# manchester encoding
# This is a tad tricky because of how manchester encoding works.
# some of the burst pairs can actually contain the space from the
# pair before it and may also contain the mark for the pair after it.

# -----  ------  ----    ----  ------    ------  ------------
#     |  |    |  |  |    |  |  |    |    |    |  |
#     ----    ----  ------  ----    ------    ----
# in this example of an IR stream you have 4 timings
# that make up a 1 and a 0
# 0 = -444, +444
# 1 = +444, -444
# if you have a 1 that follows a 0 you end up with an ir encoding of
# -444, +444, +444, -444
# because we are only given on and off durations the above would be given to us as
# -444, +888, -444
#
# and if you have a 0 that follows a 1 you get
# +444, -888, +444.
# so if you have the following bit sequence 1, 0, 1, 0 you get this
# +444, -888, +888, -888, +444
# so the IR example above is going to be encoded as
# -444, +888, -444, +444, -888, +444, -444, +888, -888, +888, -444, +444
# in the example above I didn't take into account any lead in and lead out data.
# if a lead in ends in a mark or an on state. if the first bit has an on state for
# it's mark then the mark gets added to the number for the end of the lead in state.
# the same kind of rule applies to the lead out as well.
#
# the timings for the above example would be

# -444, +888, -444, +444, -888, +444, -444, +888, -888, +888, -444

# here is the same example The numbers on outside top and bottom are the actual timings
# the numbers on the inside top and bottom are the "doubled" marks and spaces split in half.

#         +888   +444   +444   +888      +888
#
#      +444 +444 +444   +444 +444 +444 +444 +444
# -----  ------  ----    ----  ------    ------  ------------
#     |  |    |  |  |    |  |  |    |    |    |  |
#     ----    ----  ------  ----    ------    ----
#    -444    -444 -444 -444 -444  -444 -444   -444
#
#    -444     -444   -888   -444    -888      -444
#
# now lets put that into order using the inside top and bottom numbers.
# -444, +444, +444, -444, +444, -444, -444, +444, -444, +444, +444, -444, -444, +444, +444, -444

# now break that into pairs.
# -444, +444
# +444, -444
# +444, -444
# -444, +444
# -444, +444
# +444, -444
# -444, +444
# +444, -444
#
# now match  the pairs to the pairs we assigned to be a 1 and a 0
# 0, 1, 1, 0, 0, 1, 0, 1
# all bits in a byte are read from right to left. the right most bit being bit 0.
# so for a number 1 the bits would be 0,0,0,0,0,0,0,1
#
# The data streams can be encoded so the data sent is msb (most significant bit) first or
# lsb (least significant bit) first
# what defines the 2 is the locations of the bits the number order they are coming in.
# for our example this is what msb and lsb do.
#
# msb bit numbers      7 6 5 4 3 2 1 0
#
# bit values           0 1 1 0 0 1 0 1
#
# lsb bit numbers      0 1 2 3 4 5 6 7
#
# so lsb and msb tell us what direction to read the bit numbers in. msb is how a typical number is encoded
# and how we read the bits, right to left
# lsb is left to right. We need to apply the bits so we would read them right to left. so with an lsb
# encoded ir signal we need to flip the whole sequence. so it would read.
# 1  0  1  0  0  1  1  0
#
# This ends up being a completely different decimal value then a stream encoded with msb.
# msb encoded = 101
# lsb encoded = 166
#
# we handle the reversing of the bits when collecting the parameters from the code.


import math
from . import DecodeError


class CodeWrapper(object):
    @property
    def encoding(self):
        return self._encoding

    @property
    def original_code(self):
        return self._original_code[:]

    @property
    def burst_pairs(self):
        return self._bursts[:]

    @property
    def tolerance(self):
        return self._tolerance

    @property
    def stream_encoding(self):
        return self._stream_encoding

    @property
    def stream_pairs(self):
        return self._stream_pairs[:]

    def _get_stream_encoding(self, bursts):
        if bursts:
            last_pair = bursts[0]

            if isinstance(last_pair, int):
                return 'bit'
            else:
                for mark, space in bursts[1:]:
                    if (
                        mark == last_pair[1] and
                        space == last_pair[0]
                    ):
                        return 'manchester'

                    last_pair = [mark, space]

        return 'pulse_width'

    def _decode_bit(
        self,
        num_bits,
        lead_in,
        bursts,
        middle_timings,
        lead_out
    ):
        cleaned_code = []
        code = self._original_code

        for e_burst in lead_in:
            try:
                burst = code.pop(0)
            except IndexError:
                raise DecodeError('Invalid code')

            if self._match(burst, e_burst):
                cleaned_code += [e_burst]
                continue

            for timing in bursts:
                multiplier = (burst - e_burst) // timing
                if multiplier == 0:
                    continue

                if self._match(burst, timing * multiplier + e_burst):
                    code.insert(0, burst - e_burst)
                    cleaned_code += [e_burst]
                    break
            else:
                raise DecodeError('Invalid lead in')

        pairs = []
        mark, space = bursts

        while len(pairs) // 2 < num_bits:
            try:
                burst = code.pop(0)
            except:
                raise DecodeError('not enough bits')

            multiplier = burst // mark

            if multiplier <= 0:
                multiplier = burst // space
                if multiplier <= 0:
                    raise DecodeError('Invalid burst')
                timing = space

            else:
                timing = mark

            if self._match(burst, timing * multiplier):
                cleaned_code += [timing] * multiplier
                pairs += [timing] * multiplier
            else:
                raise DecodeError('Invalid burst')

        return pairs, cleaned_code

    def _decode_manchester(
        self,
        num_bits,
        lead_in,
        bursts,
        middle_timings,
        lead_out
    ):
        cleaned_code = []
        code = self._original_code

        for i, e_burst in enumerate(lead_in):
            try:
                burst = code.pop(0)
            except IndexError:
                raise DecodeError('Invalid lead in')

            if self._match(burst, e_burst):
                cleaned_code += [e_burst]
                continue

            if i == len(lead_in) - 1:
                for mark, _ in bursts:
                    if self._match(burst - mark, e_burst):
                        code.insert(0, mark)
                        cleaned_code += [e_burst]
                        break
                else:
                    raise DecodeError('Invalid lead in ' + str(code))

                break

            raise DecodeError('Invalid lead in ' + str(code))

        pairs = []
        mark, space = bursts[0]

        while len(pairs) // 2 < num_bits:
            try:
                burst = code.pop(0)
            except IndexError:
                raise DecodeError('not enough bits')

            if lead_out and len(code) + 1 == len(lead_out):
                if len(pairs) % 2:
                    if pairs[-1] == mark:
                        pairs += [space]
                        cleaned_code += [space]
                        code.insert(0, burst - space)
                    else:
                        pairs += [mark]
                        cleaned_code += [mark]
                        code.insert(0, burst - mark)

                    break

                code.insert(0, burst)
                break

            for timing in middle_timings:
                if timing.hit_test(len(cleaned_code)):
                    if timing.type == 'bit':
                        t_mark, t_space = timing[len(cleaned_code) - (len(cleaned_code) % 2)]

                        if self._match(burst, t_mark):
                            pairs += [t_mark]
                            cleaned_code += [t_mark]
                            break

                        if self._match(burst, t_space):
                            pairs += [t_space]
                            cleaned_code += [t_space]
                            break

                        if (
                            (t_mark < 0 > mark or t_mark > 0 < mark) and
                            self._match(burst, t_mark + mark)
                        ):
                            pairs += [mark, t_mark]
                            cleaned_code += [mark, t_mark]
                            break

                        if (
                            (t_mark < 0 > space or t_mark > 0 < space) and
                            self._match(burst, t_mark + space)
                        ):
                            pairs += [space, t_mark]
                            cleaned_code += [space, t_mark]
                            break

                        if (
                            (t_space < 0 > space or t_space > 0 < space) and
                            self._match(burst, t_space + space)
                        ):
                            pairs += [t_space, space]
                            cleaned_code += [t_space, space]
                            break

                        if (
                            (t_space < 0 > mark or t_space > 0 < mark) and
                            self._match(burst, t_space + mark)
                        ):
                            pairs += [t_space, mark]
                            cleaned_code += [t_space, mark]
                            break

                    elif len(timing) == 2:
                        t_mark, t_space = list(timing)

                        if cleaned_code[-1] == t_mark:
                            if (
                                (t_space < 0 > mark or t_space > 0 < mark) and
                                self._match(burst, mark + t_space)
                            ):
                                pairs += [mark]
                                cleaned_code += [t_space, mark]
                                middle_timings.remove(timing)
                                break

                            if (
                                (t_space < 0 > space or t_space > 0 < space) and
                                self._match(burst, space + t_space)
                            ):
                                pairs += [space]
                                cleaned_code += [t_space, space]
                                middle_timings.remove(timing)
                                break

                            if self._match(burst, t_space):
                                cleaned_code += [t_space]
                                middle_timings.remove(timing)
                                break

                        elif self._match(burst, t_mark):
                            cleaned_code += [t_mark]
                            break

                        elif (
                            (t_mark < 0 > mark or t_mark > 0 < mark) and
                            self._match(burst, t_mark + mark)
                        ):
                            pairs += [mark]
                            cleaned_code += [mark, t_mark]
                            break

                        elif (
                            (t_mark < 0 > space or t_mark > 0 < space) and
                            self._match(burst, t_mark + space)
                        ):
                            pairs += [space]
                            cleaned_code += [space, t_mark]
                            break
                    else:
                        t_burst = timing[len(cleaned_code)]

                        if self._match(burst, t_burst):
                            cleaned_code += [t_burst]
                            middle_timings.remove(timing)
                            break
                        if (
                            (t_burst < 0 > mark or t_burst > 0 < mark) and
                            self._match(burst, t_burst + mark)
                        ):
                            pairs += [mark]
                            cleaned_code += [mark, t_burst]
                            middle_timings.remove(timing)
                            break
                        if (
                            (t_burst < 0 > space or t_burst > 0 < space) and
                            self._match(burst, t_burst + space)
                        ):
                            pairs += [space]
                            cleaned_code += [space, t_burst]
                            middle_timings.remove(timing)
                            break

                    raise DecodeError(
                        'Invalid burst ',
                        self._original_code,
                        cleaned_code,
                        pairs,
                        timing
                    )

            else:
                if self._match(burst, mark):
                    pairs += [mark]
                    cleaned_code += [mark]
                    continue

                if self._match(burst, space):
                    pairs += [space]
                    cleaned_code += [space]
                    continue

                if self._match(burst, mark * 2):
                    pairs += [mark, mark]
                    cleaned_code += [mark, mark]
                    continue

                if self._match(burst, space * 2):
                    pairs += [space, space]
                    cleaned_code += [space, space]
                    continue

                if (
                    lead_in and
                    lead_in[-1] == -999999999999 and
                    len(code) == 1
                ):
                    if len(pairs) % 2:
                        for mark, space in bursts:
                            if space > 0:
                                continue

                            if mark == pairs[-1]:
                                pairs += [space]
                                cleaned_code += [space, burst - space]
                                break
                        else:
                            raise DecodeError(
                                'Invalid burst ',
                                self._original_code,
                                cleaned_code,
                                pairs
                            )
                    else:
                        cleaned_code += [space, burst]

                    if code and burst == code[-1]:
                        if cleaned_code[-1] == mark:
                            cleaned_code += [space]
                            self._original_code[-len(code)] = space
                            pairs += [space]
                        else:
                            cleaned_code += [mark]
                            self._original_code[-len(code)] = mark
                            pairs += [mark]

                    continue

                raise DecodeError(
                    'Invalid burst ',
                    self._original_code,
                    cleaned_code,
                    pairs
                )

        tmp = []

        extra_timings = list(timing.bursts for timing in middle_timings if timing.type == 'bit')
        if extra_timings:
            extra_timings = extra_timings[0]

        for i in range(0, len(pairs), 2):
            mark = pairs[i]
            try:
                space = pairs[i + 1]
                if [mark, space] in extra_timings:
                    mark, space = bursts[extra_timings.index([mark, space])]

                tmp += [mark, space]
            except IndexError:
                tmp += [mark]

        pairs = tmp[:]

        return pairs, cleaned_code

    def _decode_pulse_width(
        self,
        num_bits,
        lead_in,
        bursts,
        middle_timings,
        lead_out
    ):
        cleaned_code = []
        code = self._original_code

        for i, e_burst in enumerate(lead_in):
            try:
                burst = code.pop(0)
            except IndexError:
                raise DecodeError('Invalid lead in')

            if self._match(burst, e_burst):
                cleaned_code += [e_burst]
                continue

            if i == len(lead_in) - 1:
                for mark, _ in bursts:
                    if self._match(burst - mark, e_burst):
                        code.insert(0, mark)
                        cleaned_code += [e_burst]
                        break
                else:
                    raise DecodeError('Invalid lead in ', code, cleaned_code, burst, e_burst)

                break

            raise DecodeError('Invalid lead in ' + str(code))

        pairs = []

        def _check_timing():
            if timing.type == 'bit':
                for m, s in timing:
                    if (
                        self._match(burst, m) and
                        self._match(code[0], s)
                    ):
                        cleaned_code.append(m)
                    elif (
                        self._match(burst, s) and
                        self._match(cleaned_code[-1], m)
                    ):
                        cleaned_code.append(s)
                    elif (
                        self._match(burst, m + space) and
                        self._match(code[0], s)
                    ):
                        pairs.append(space)
                        cleaned_code.extend([space, m])

                    elif (
                        self._match(burst, s + mark) and
                        self._match(cleaned_code[-1], m)
                    ):
                        pairs.append(mark)
                        cleaned_code.extend([s, mark])
                    elif (
                        cleaned_code[-1] == space and
                        self._match(burst, m)
                    ):
                        pairs.append(m)
                        cleaned_code.append(m)
                    elif (
                        cleaned_code[-1] == s and
                        self._match(burst, m)
                    ):
                        pairs.append(m)
                        cleaned_code.append(m)
                    elif (
                        cleaned_code[-1] == m and
                        self._match(burst, s)
                    ):
                        pairs.append(s)
                        cleaned_code.append(s)
                    else:
                        raise DecodeError('Invalid timing')

            elif len(timing) == 2:
                m, s = list(timing)
                if (
                    self._match(burst, m) and
                    self._match(code[0], s)
                ):
                    cleaned_code.append(m)
                elif (
                    self._match(burst, s) and
                    self._match(cleaned_code[-1], m)
                ):
                    cleaned_code.append(s)
                    middle_timings.remove(timing)

                elif (
                    self._match(burst, m + space) and
                    self._match(code[0], s)
                ):
                    pairs.append(space)
                    cleaned_code.extend([space, m])
                elif (
                    self._match(burst, s + mark) and
                    self._match(cleaned_code[-1], m)
                ):
                    pairs.append(mark)
                    cleaned_code.extend([s, mark])
                    middle_timings.remove(timing)

                elif (
                    cleaned_code[-1] == space and
                    self._match(burst, m)
                ):
                    pairs.append(m)
                    cleaned_code.append(m)
                elif (
                    cleaned_code[-1] == s and
                    self._match(burst, m)
                ):
                    pairs.append(m)
                    cleaned_code.append(m)
                elif (
                    cleaned_code[-1] == m and
                    self._match(burst, s)
                ):
                    pairs.append(s)
                    cleaned_code.append(s)
                    middle_timings.remove(timing)
                else:
                    raise DecodeError('Invalid timing')
            else:
                m = timing[-1]

                if self._match(burst, m):
                    cleaned_code.append(m)
                    middle_timings.remove(timing)
                elif self._match(burst, m + mark):
                    cleaned_code.extend([m, mark])
                    pairs.append(m)
                    middle_timings.remove(timing)
                elif self._match(burst, m + space):
                    cleaned_code.extend([space, m])
                    pairs.append(space)
                    middle_timings.remove(timing)
                else:
                    raise DecodeError('Invalid timing')

        while len(pairs) // 2 < num_bits:
            try:
                burst = code.pop(0)
            except IndexError:
                raise DecodeError('not enough bits')

            for mark, space in bursts:
                if (
                    lead_out and
                    len(code) + 1 == len(lead_out) and
                    num_bits * 2 == len(pairs) + 1
                ):
                    if len(lead_out) % 2:
                        if len(lead_out) == 1 and lead_out[0] > 0 > space:
                            if mark == pairs[-1]:
                                code.insert(0, burst - space)
                                cleaned_code += [space]
                                pairs += [space]
                                break

                        elif mark == pairs[-1] and space > burst:
                            code.insert(0, burst - space)
                            cleaned_code += [space]
                            pairs += [space]
                            break

                    elif mark == pairs[-1] and space > 0 < lead_out[0]:
                        code.insert(0, burst - space)
                        cleaned_code += [space]
                        pairs += [space]
                        break

                for timing in middle_timings:
                    if timing.hit_test(len(cleaned_code)):
                        try:
                            _check_timing()
                            break
                        except IndexError:
                            raise DecodeError('Invalid timing')
                else:
                    if self._match(burst, mark):
                        pairs += [mark]
                        cleaned_code += [mark]
                        break
                    if self._match(burst, space):
                        pairs += [space]
                        cleaned_code += [space]
                        break

                    continue

                break
            else:
                raise DecodeError(
                    'Invalid timing',
                    self._original_code,
                    cleaned_code,
                    pairs
                )

        return pairs, cleaned_code

    def _sanity_checks(self, middle_timings, lead_out):
        if len(self._original_code) < len(lead_out):
            # sanity check
            return False

        if len(self._stream_pairs) % 2:
            return False

        for timing in middle_timings:
            if timing.type == 'timing':
                return False

        return True

    def _decode_pairs(self, bursts, cleaned_code):
        decoded_code = []

        for i in range(0, len(self._stream_pairs), 2):
            bp = [self._stream_pairs[i], self._stream_pairs[i + 1]]
            if bp in bursts:
                decoded_code += [bursts.index(bp)]
            else:
                raise DecodeError(
                    'Invalid burst pair',
                    self._original_code,
                    cleaned_code,
                    self._stream_pairs
                )

        return decoded_code

    def _build_normalized_code(self, lead_out, cleaned_code):
        for i, e_burst in enumerate(lead_out):
            if e_burst == -999999999999:
                break

            burst = self._original_code.pop(0)

            if self._match(burst, e_burst):
                cleaned_code += [e_burst]

            elif i == len(lead_out) - 1:
                if e_burst > 0:
                    total_time = -(e_burst - sum(abs(item) for item in cleaned_code))
                    cleaned_code += [total_time]
                else:
                    cleaned_code += [e_burst]
            else:
                raise DecodeError('Invalid lead out', lead_out, cleaned_code, self._original_code, burst)

        del self._original_code[:]

        if not cleaned_code:
            raise DecodeError('Invalid code')

        elif cleaned_code[-1] == 0:
            if lead_out and lead_out[-1] < 0:
                cleaned_code[-1] = lead_out[-1]

                if cleaned_code[-2] < 0:
                    self._original_code += [cleaned_code[-2] + lead_out[-1]]
                else:
                    self._original_code += [lead_out[-1]]
            else:
                raise DecodeError('Invalid lead out')

        normalized_code = []
        for pulse in cleaned_code:
            if (
                len(normalized_code) and
                (normalized_code[-1] < 0 > pulse or normalized_code[-1] > 0 < pulse)
            ):
                normalized_code[-1] += pulse
                continue

            normalized_code += [pulse]

        return normalized_code

    def __init__(
        self,
        encoding,
        lead_in,
        lead_out,
        middle_timings,
        bursts,
        tolerance,
        num_bits,
        code
    ):
        self._encoding = encoding
        self._lead_in = lead_in[:]
        self._lead_out = lead_out[:]
        self._bursts = bursts[:]
        self._num_bits = num_bits
        self._tolerance = tolerance
        self._middle_timings = middle_timings[:]
        self._original_code = code[:]
        self._stream_encoding = self._get_stream_encoding(bursts)

        if self._stream_encoding == 'bit':
            self._stream_pairs, cleaned_code = self._decode_bit(
                num_bits,
                lead_in,
                bursts,
                middle_timings,
                lead_out
            )
        elif self._stream_encoding == 'manchester':
            self._stream_pairs, cleaned_code = self._decode_manchester(
                num_bits,
                lead_in,
                bursts,
                middle_timings,
                lead_out
            )
        elif self._stream_encoding == 'pulse_width':
            self._stream_pairs, cleaned_code = self._decode_pulse_width(
                num_bits,
                lead_in,
                bursts,
                middle_timings,
                lead_out
            )
        else:
            # sanity check
            raise DecodeError('This should not happen')

        if not self._sanity_checks(middle_timings, lead_out):
            raise DecodeError(
                'failed sanity checks',
                middle_timings,
                self._original_code,
                cleaned_code,
                self._stream_pairs
            )

        self._decoded_code = self._decode_pairs(bursts, cleaned_code)
        self._code = self._build_normalized_code(lead_out, cleaned_code)
        if self._original_code:
            self._original_code = code[:len(self._code) - 1] + self._original_code
        else:
            self._original_code = code[:len(self._code)]


    def _match_pair(self, mark, space, expected_mark, expected_space):
        return (
            self._match(mark, expected_mark) and
            self._match(space, expected_space)
        )

    def _match(self, value, expected_timing_value):
        if value < 0 < expected_timing_value or value > 0 > expected_timing_value:
            return False

        high = math.floor(expected_timing_value + (expected_timing_value * (self._tolerance / 100.0)))
        low = math.floor(expected_timing_value - (expected_timing_value * (self._tolerance / 100.0)))

        # do a flip flop of the high and low so the same expression can
        # be used when evaluating a raw timing
        if expected_timing_value < 0:
            low, high = high, low

        return low <= value <= high

    def __iter__(self):
        for item in self._code:
            yield item

    def __getitem__(self, item):
        return self._code[item]

    def get_value(self, start_bit, stop_bit):
        bits = self._decoded_code[start_bit: stop_bit + 1]

        if self._encoding.startswith('msb'):
            bits = list(bits[i] for i in range(len(bits) - 1, -1, -1))

        res = 0
        for i, item in enumerate(bits):
            res = self._set_bit(res, i, item)

        return res

    @staticmethod
    def _set_bit(value, bit_num, state):
        if state:
            return value | (1 << bit_num)
        else:
            return value & ~(1 << bit_num)

    @staticmethod
    def _get_bit(value, bit_num):
        return int(value & (1 << bit_num) > 0)

    @property
    def lead_in(self):
        return self._lead_in[:]

    @property
    def lead_out(self):

        lead_out = self._lead_out[:]
        if lead_out and lead_out[-1] > 0:
            tt = sum(abs(item) for item in self._code[:-1])
            lead_out[-1] = tt - lead_out[-1]

        return lead_out

    @property
    def num_bits(self):
        return len(self._decoded_code)

    @property
    def bits(self):
        return self._decoded_code[:]

    def get_burst_pair(self, index):
        return self._stream_pairs[index]
